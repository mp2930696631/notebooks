# linux中的变量

```
局部变量：本shell可见
环境变量：本shell进程以及其子进程可见

开启新的shell的两个方式
1、sh
2、bash
```

# linux 命令

## 命令分类

```
linux命令分为内部命令和外部命令
内部命令：shell自带的命令
外部命令：不是shell自带的命令，由用户自己安装的
```

## 什么是shell

```
什么是shell：
shell就是一个应用程序，我们通过它来操作linux内核！！，当我们使用用户名和密码登录的时候，实际上进入的就是shell这个应用程序。常用的shell例如：bash shell
```

## linux命令的执行流程

```
linux命令的执行流程：
1、用户使用用户名和密码登录进linux系统(也就是shell程序中)
2、用户提交命令（回车）到shell程序
3、shell程序按空格进行切分，第一个字符串被看成是命令，后面的字符串被看成是命令的参数
4、然后，shell程序将判断命令的类型：是内部命令还是外部命令
5、如果是内部命令，直接交给linux内核处理就可以了
6、如果是外部命令，先需要找到该命令的可执行程序（在PATH路径下去寻找，并不是整个文件系统，所以执行外部命令并不慢），再交给linux内核
```

## man

```
man <命令>
查看外部命令的帮助文档

enter：翻一行
空格：向后翻页
q：退出
b：向前翻页
```

## help

```
help <命令>
查看内部命令的帮助文档
```

## hash优化命令查询时间

```
由于在执行外部命令的时候，shell程序需要去寻找可执行程序，所以，linux做了一些优化
1、只会在PATH路径下面去查找
2、执行过的外部命令，会被缓存到hash表中，方便下次执行（可以使用hash命令查看hash表）
```



## 重要命令

### 进程管理

#### ps -ef 

```
查看进程相关信息
```

#### kill -9 <进程id>

```
强制干掉进程
```

### echo

```
输出
```

### echo $$

```
输出本shell程序的进程id
```

### 



## 入门级别

### type 

```shell
type <命令>

查看命令类型，是linux内部命令还是外部命令
如果看到builtin关键字，表示是内部命令，否则，表示该命令是外部命令

内部命令：shell自带的命令
外部命令：不是shell自带的命令，由用户自己安装的

什么是shell：shell就是一个应用程序，我们通过它来操作linux内核！！，当我们使用用户名和密码登录的时候，实际上进入的就是shell这个应用程序。常用的shell例如：bash shell
```

### file 

```
file <文件名>

查看文件类型
```

### cat

```
cat <文件名>

查看文件内容
```

### whereis

```
whereis <命令>

查看命令所在的路径
```

### pwd

```
显示当前目录的路径
```

## 文件系统相关的命令

### df

```
df
查看系统分区情况

df -h
查看系统分区情况，并采用GB的形式显示
```

### du

```
du <文件夹>
查看该文件夹下的各子目录大小

du -h <文件夹>
带单位查看该文件夹下的各子目录大小
```

==一般情况下df和du联合起来使用，先使用df查看是哪个分区的负载高，再使用du查看具体是哪个文件夹的负载高==

### ls

```
1、ls
显示当前文件夹下的文件

2、ls -a
包括隐藏文件

3、ls -l（=ll）
文件类型+属主权限+组内其他用户权限+其他用户权限 文件的硬链接数 属主 属组 大小 ...

文件类型：
-：文件
d：目录
b：块设备
c：字符设备
l：软链接（硬链接是-标识，和普通文件是一样的）
p：管道
s：套接字（socket）

4、ls -il （=ll -i）
可以显示inode号
```

### cd

```
改变shell的工作目录

使用cd或者使用cd ~表示回家

cd ..
返回上一级目录
```

### pwd

```
显示当前目录的路径
```

### mkdir

```
创建文件夹

mkdir -p <文件夹>
级联创建目录

mkdir <文件夹1> <文件夹2> ...
同事创建多个文件夹
```

### cp

```
cp 源文件 目标目录/文件
如果目标是文件且存在，则覆盖目标文件的内容，但是不改变目标文件名。如果目标文件不存在，则表示复制+重命名

cp -r 目录 目标目录
复制目录
```

### mv

```
mv 源文件 目标目录
移动文件

mv 源文件 目标文件
移动+重命名
```

### rm

```
rm <文件名>
删除文件

rm -f
强制删除

rm -rf
递归删除文件夹
```

### ln

```
ln 源文件 目标文件
为源文件创建一个硬链接

ln -s 源文件 目标文件
为源文件创建软连接
```

硬链接

![](F:\zehua\personalFiles\newStart\其他\linux学习\linux入门图片\QQ截图20210322160815.png)

软链接

![](F:\zehua\personalFiles\newStart\其他\linux学习\linux入门图片\QQ截图20210322160915.png)

### stat

```
查看文件的详细信息

access：最近一次访问的时间戳
modify：最近一次修改的时间戳
change：最近一次修改文件元数据信息/文件内容的时间戳（例如修改文件权限等）
```

### touch

```
touch <文件名>
当该文件不存在的时候，表示创建文件
当该文件存在的时候，会使该文件的access、modify、change的时间戳都变成一样
```

## 文件操作相关的命令

### cat

```
cat <文件名> <文件名>
查看文件内容

如果文件内容超过一个屏幕，则不方便查看，推荐使用more命令
```

### more

```
more <文件名>
查看文件内容，分页显示
按空格：分页查看
按enter：一行一行查看

如果想往回看，推荐使用less命令
```

### less

```
less <文件名>
查看文件内容，分页显示
按空格：查看下一页
按enter：查看下一行
按b：查看上一页
```

### head

```
head <文件名>
查看文件前10行数据

head -n <文件名>
查看文件前n行数据
```

### tail

```
tail <文件名>
查看文件后10行数据

tail -n <文件名>
查看文件后n行数据

tail -f <文件名>
输出增量数据
```

### xargs

```
与管道|配合使用，可以接受输出，并转化为xargs后面所接命令的初始参数。可以解决无法接受管道输出的命令，如ls -l
echo '/' | xargs ls -l
```

### cut

```
显示切割的行数据

-f：选择显示的列（例如-f1,2）
-s：不显示没有分隔符的列
-d：自定义分隔符
```

### sort

```
-n：按数值排序
-r：倒叙
-t：自定义分隔符
-k：选择排序列（例如-k2）
-u：合并相同行
-f：忽略大小写
```

### wc

```
统计功能（一般与管道一起使用）

wc <文件名>
统计文件中有多少行、多少个单词、多少字节

-l：多少行
-w：多少单词
-c：多少字节
```



# linux虚拟文件系统

```
分区：就是将磁盘分成不同的块，然后挂到不同的目录下
```

## 1、/bin、/sbin

```
用于存放可执行程序
/bin：用户命令
/sbin：管理命令
```

## 2、/boot

```
存放系统启动相关的文件，例如存放内核、以及相关的配置信息、引导程序等
```

## 3、/dev

```
存放设备文件的，例如鼠标、键盘、磁盘
```

## 4、/etc

```
存放配置文件
```

## 5、/home

```
用户的家目录
```

## 6、/root

```
root管理员的家目录
```

## 7、/lib

```
存放系统库文件或者第三方库文件
```

## 8、/media

```
挂载点目录，移动设备可以挂在在该目录下
```

## 9、/mnt

```
挂载点目录，额外的临时文件系统：例如u盘等
```

## 10、/opt

```
第三方程序的安装目录
```

## 11、/proc

```
伪文件系统，存放内核映射文件

因为在linux系统中，一切皆文件，进程也不例外，所以，该目录就存放进程映射成的文件，使用cd /proc/$$进入当前进程的映射成的目录

当对应的进程退出了，该目录下面的对应的文件夹就会消失
```

## 12、/sys

```
伪文件系统，存放硬件相关的属性映射文件
```

## 13、/tmp

```
临时文件，如果该文件只需要用一会，就可以将其存放在该目录下
```

## 14、/var

```
可变化文件，比如日志，需要处理的数据等
```

## 15、/usr

```
以前是用户的家目录：/usr/username
而现在是unix system resource的首字母缩写，用于存放各种资源文件，共享文件、数据、等，例如共享的二进制文件
```



# linux的文本编辑器vi

```
编辑模式：
使用vi打开一个文件所处的状态，默认光标位于第一行
vi +n <文件名>
打开文件后，使光标移动到第n行
vi + <文件名>
打开文件后，使光标移动到末尾

输入模式
末行模式
```

## 编辑模式下一些操作

### 1、光标的移动

```
在编辑模式下
w：移动到下一个单词的首字母
b：移动到上一个单词的首字母
e：移动到下一个单词的词尾

0：移动到该行的绝对行首
^：移动到该行第一个非空字符上
shift+$：移动到该行的行尾

G（或者说是shift+g）：移动到末行
gg：移动到首行
8G：移动到第8行
```

### 2、翻页

```
在编辑模式下
ctrl+f：向后翻页
ctrl+b：向前翻页
```

### 3、删除

```
x：删除光标前一个字符
3x：删除光标前3个字符

dG：删除光标一下的所有行
d$：删除光标后面的同行的所有字符
dd：删除光标所在行
dw：每次删除一个单词
yw：复制光标所在的一个单词
p：将内容粘贴到光标后面（如果使用的是yy命令来复制的话，表示向下粘贴一行）
P（或者说是shift+p）：将内容粘贴到光标前面（如果使用的是yy命令来复制的话，表示向上粘贴一行）
yy：复制光标所在行
u：撤销
ctrl+r：恢复
.：重复上一次操作
```

### 4、替换

```
r：替换光标字符
```

### 5、进入输入模式

```
i：在光标的的前方进入输入模式
a：在光标的后方进入输入模式
o：在光标的下方新建一行
O（shift+o）：在光标的上方新建一行
A（shift+a）：将光标移动到行尾，并进入输入模式
```

### 6、进入末行模式

```
按下冒号（:）
```



## 输入模式下的一些操作

### 1、进入编辑模式

```
按下esc
```

## 末行模式下的一些操作

### 1、保存文件

```
按下w，回车，但是不会退出文本编辑器

如果想退出，需要再按下:q，回车

或者:wq（=shift+zz）

:w!
强行保存
```

### 2、退出vi

```
:q

强制退出(不保存并退出)
:q!
```

### 3、其他骚操作

```
set nu (set number)
设置行号

set nonu （set nonumber）
隐藏行号

/<关键字>
向下查找关键字
按n：下一个关键字
按N(shift+n)：上一个关键字

?<关键字>
向上查找关键字
按n：上一个关键字
按N(shift+n)：下一个关键字

!<命令>
在末行模式下执行命令

s/<关键字A>/<关键字B>
将光标所在行的第一个关键字A，替换成关键字B

s/<关键字A>/<关键字B>/g
将光标所在行的全部关键字A，替换成关键字B

s/<关键字A>/<关键字B>/gi
将光标所在行的全部关键字A，替换成关键字B（忽略关键字A的大小写）

%s/<关键字A>/<关键字B>/gi（=0,$s/<关键字A>/<关键字B>/gi）
全文替换（忽略关键字A的大小写）

.,+ns/<关键字A>/<关键字B>/gi
将光标所在行以及之后的n行的关键字A，替换成关键字B（忽略关键字A的大小写）

.表示光标所在行
$表示末行
+n表示偏移n行
$-3表示倒数第四行
```

### 4、删除

```
0,$d
全部删除

.,+2d
删除光标以及下面两行

nd
删除第n行
```

### 5、复制粘贴

```
ny
复制第y行

0，ny
复制第零行到第n行

如果是粘贴的话，使用的p或者P
```

# linux中的行编辑器sed

```
以行为单位进行处理,在进行处理的时候，是一行一行的读取进内存的，默认情况下，会显示模式空间（内存）中的数据，如果想不显示，需要加上-n

sed [options] 'command' file1

options：
-n：静默模式，也就是不显示模式空间中的数据
-i：直接修改原文件（原理：先在内存中删除，再将内存中的数据写回磁盘）
-r：使用扩展正则表达式

command：
d：删除
sed '3d' txt 删除第三行

p：显示内容
sed -n '3p' txt 显示第三行（注意需要加上-n，不然会将txt的内容都显示出来，并且，第三行显示两次）

a：在行的下方添加内容
sed 'ahello' txt 在txt中每一行的下方添加hello
sed '$ahello' txt 在txt的最后一行的下方添加hello

i：在行的上方添加内容
sed 'ihello' txt 在txt中每一行的上方添加hello

c：替换
sed 'chello' txt 将txt的内容全部替换成hello
sed '3chello' txt 将txt的第3行替换成hello

s/pattern/string/ 查找并替换，默认只替换每行中的第一个被模式匹配到的字符串
	g：行内全部替换 s/pattern/string/g
	i：忽略大小写 s/pattern/string/gi
```

# linux中的文本分析工具awk

```
原理：awk将文本逐行读入，并且使用分隔符进行切割（默认为空格、制表符），在将切开的部分进行各种分析处理

-F：自定义分隔符
-f：添加脚本文件，也就是将原先在''中的内容放置到一个文件中，注意，此文件需要格式化，安装java的格式来进行调整即可

awk的内置变量：
NF：切分出的域的个数（也就是一行被切分成多少块）
NR：已读的记录的个数（可用来编号）

支持函数：如print、split
（split函数需要传入三个参数：需要处理的字符串、保存结果的数组、分隔符）

支持流程控制语句：如while、for

支持数组：例如a[1]、a[tom]...

BEGIN：在开头打印
END：在结尾打印
$0：表示原始行
```

## 练习

```
只显示/etc/passwd的账户
awk -F ':' '{print $1}' passwd

只显示/etc/passwd的账户和账户对应的shell，而账户与shell之间使用逗号分隔，而且在所有行开始前添加列明name,shell，在最后一行添加end
awk -F ':' 'BEGIN{print "name,shell"} {print $1 "," $7} END{print "end"}' passwd

搜索/etc/passwd有root关键字的所有行
awk '/root/ {print $0}' passwd 
（所有使用/关键字/）

统计/etc/passwd文件中的，每行的行号、每行的列数、对应的完整行内容
awk -F ':' '{print NR "\t" NF "\t" $0}' passwd

统计报表：
合计每个人一月份的工资，其中（0：manager，1：worker）
数据：
tom	0	2012-12-11	car	5000
john	1	2012-01-11	bike	1000
vivi	1	2012-01-11	car	2800
tom	0	2012-01-11	car	2500
john	1	2012-01-11	bike	3500
输出结果：
vivi	worker	2800
tom	worker	2500
......
awk '{split($3, date, "-"); if(date[2]=="01"){names[$1]+=$5; if($2=="0"){roles[$1]="manager"}else{roles[$1]="worker"}}} END{for(i in names){print i "\t" roles[i] "\t"  names[i]}}' testAwk

使用脚本：
脚本内容
{
	split($3, date, "-"); 
	if(date[2]=="01"){
		names[$1]+=$5; 
		if($2=="0"){
			roles[$1]="manager"
		}else{
			roles[$1]="worker"
		}
	}
} 
END{
for(i in names){
	print i "\t" roles[i] "\t"  names[i]
}
}
awk -f awkScript testAwk
```



# linux中使用正则表达式

## 1、匹配操作符

```
\ 转义字符
. 匹配任意字符
[字符序列] 匹配字符序列中的任意字符
[^字符序列] 匹配非字符序列中的任意字符
[a-z] 匹配a-z的任意字符
^ 开头
$ 结尾
\<hello\> 单词首尾边界（也就是只有hello这个单词的才能匹配上，不能多，也不能少）
\<hello 锚定单词词首
hello\> 锚定单词词尾
| 连接操作符（表示或者）
() 选择操作符（需要与|连起来使用）
\n 表示反向引用（也就是将()中的内容看成一个整体，并加以引用，例如\1表示引用第一个()中的内容）
```

## 2、重复操作符

```
? 匹配0或者1个
* 匹配0或者多个
+ 匹配1或者多个
{n} 匹配n次
{n,} 匹配n到多次
{n,m} 匹配n-m次
（{ 是属于扩展的正则表达式，当使用grep的时候，需要使用转义符号，或者使用grep -E。所以尽量使用grep -E）
```

## 3、grep 

```
grep 正则表达式 <文件名>
按正则表达式进行匹配
```

# linux中的用户管理

```
useradd
usermod
userdel
id <username>:查看用户信息
chown
chmod

注意：同时打开两个shell，在一个shell中进行用户相应信息的修改，在另一个shell是不可见的，原因在于，另一个shell中内存中相关的用户信息并没有变化
```

## 添加用户

```
useradd <username>
再使用passwd修改密码才可以使用
```

## 修改用户

```
usermod [option] ...
usermod -G <groupname> <username>
将用户添加到group中
```

## 删除用户

```
userdel <username>
这样是删不干净的，还需要
删除用户家目录
以及/var/spool/mail下的用户邮箱
```

## 添加组

```
groupadd <groupname>
```

## 删除组

```
groupdel <groupname>
```



## 修改密码

```
passwd <username>
```

## 改变文件属主和属组

```
chown <属主>:<属组> <文件名>
-R：递归改变

chown :<属组> <文件名> 不改变属主
chown <属主>: <文件名> 不改变属组
```

## 修改权限

```
chmod 权限 <文件名>
chmod 777 ...
-R：递归改变

u：表示属主 chmod u+w 
g：表示属组 chmod g+r
o：表示其他用户 chmod o-x
(推荐这种方式)
```

## sudo

```
普通用户执行需要root权限的操作，需要root用户赋予普通用户sudo权限。将命令进程以root权限运行

配置文件/etc/sudoers，推荐使用visudo进行编辑，因为其会进行语法检查 (具体怎么配置，暂不需要关心)

sudo -l 查看当前用户是否有sudo权限

由于root用户切换用户是不需要密码的，所以，如果一个用户可以以root权限运行su命令（sudo su <username>），就可以不需要输入密码而任意切换用户了
```

## su

```
su <username>
切换用户
root-》普通用户，不需要输入密码
其他情况，需要密码
```

# rpm安装软件

```
（依赖的包不会自动下载）

rpm -ivh <filename> 安装
rpm -e <filename> 卸载

rpm -qa 查询所有已经安装的包
rpm -q <filename> 查询已经安装的包
rpm -qi <filename> 查询指定包的说明信息
rpm -ql <filename> 查询指定包安装后生成的文件列表
rpm -qd <filename> 查询指定包安装的帮助文件
rpm -qf /path/to/somefile 查询该文件是由哪个rpm包安装生成的
```

# yum安装软件

```
yum全称yellow dog updater ，是一个包管理器，基于rpm包管理，可以从指定服务器自动下载rpm包并且安装，可以自定处理依赖关系，并且一次安装所有依赖的软件包

https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11BJaPbf

先yum clean all 清空本地依赖的缓存
再yun makecache 将依赖缓存下载到本地
（依赖缓存指的是一个软件的依赖关系，在安装一个软件前，首先需要向源请求其依赖关系，然后再下载安装依赖。将依赖缓存到本地，就省去了这个步骤）
安装软件 yum install <软件名> [-y]（-y可选，表示全部都是yes）
```

## 配置网络源

```
https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11BJaPbf
```

## 配置本地源

```
在没有网络的环境下，需要使用这种方式下载软件

1、首先需要挂在一个磁盘提供软件
mount /dev/cdrom /mnt（挂载）

2、修改/etc/yum.repos.d/下的CentOS-Base.repo文件
只需要保留[base]这部分，内容如下
name=local
baseurl=file:///mnt
gpgcheck=1
enable=1（表示启用本地源）

3、
yum clean all
yum makecache
yum repolist（查看一共有多少软件）
```

# /etc/profile

```
/etc/profile 只会在第一次登陆系统（不包括切换用户）的时候被执行
/etc/bashrc 每次执行bash的时候都会被执行（所有用户）
~/.bashrc 每次执行bash的时候都会被执行（只不过，这里是与特定用户相关的）

~/.bash_logout
~/.bash_profile
（这两个不用管）
```

